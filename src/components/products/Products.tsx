import { useAppSelector } from "../../redux/store"
import IndividualProductComponent from "./IndividualProductComponent"
import { Item, itemTypesArray } from "../../data/generalDatabase"
import { ReactElement, useState } from "react"
import LoadingScreenProducts from "./loadingScreens/ProductsLS"
import { filterProductDisplay } from "../../utilities/miscFunctions"
import ProductFiltering, { ProductFilter, TypeFilterForm } from "./misc/ProductFiltering"
import { Fragment } from "react"
import NoProductsMatch from "./misc/NoProductsMatch"

export default function Products() {

    const productsDatabase = useAppSelector(state => state.products.items)
    const allProducts: Item[] = productsDatabase.data
    const productsFetchStatus = productsDatabase.status

    let productDisplay: ReactElement[] | ReactElement = []
    
    const initialTypeFilter: TypeFilterForm =                       // This is handled in this (slightly convoluted) way in order to generate a dependency between this initial filter state and the 'itemTypes' enum in generalDatabase, which in turn makes the code more easily maintainable
        Object.assign({},                                           // Using Object.assign in order to get all single-parameter objects generated by .map() inside the same object
            ...itemTypesArray                                       // Generating a dependency to the enum itemTypes
                    .map(itemType => {return { [itemType]: false }} // Returning an object parameter initialized in 'false' for all item types in the enum
                )
            )

    const [productFilter, setProductFilter] = useState<ProductFilter>({
        searchbar: '',
        typeFilter: initialTypeFilter // This object will look like this: { shirts: false, pants: false, etc }
    })

    if (productsFetchStatus == 'success') { // Loading screen interface
        const finalProductDisplay: Item[] = filterProductDisplay(productFilter, allProducts)
        productDisplay = finalProductDisplay.map((product: Item) => {
            return (
                <Fragment key={product?.id}>
                    <IndividualProductComponent
                        props={product}/>
                </Fragment>
            )
    })  
        if (productDisplay.length === 0) {
            productDisplay = <NoProductsMatch />
        }

    } else if (productsFetchStatus == 'loading' || productsFetchStatus == 'idle') {
        productDisplay = <LoadingScreenProducts />
    }

    return (
        <main className="container mt-4">
            <div className="row d-flex g-3">
                <ProductFiltering 
                productFilter={productFilter}
                setProductFilter={setProductFilter}/>

                {productDisplay}
            </div>
        </main>
    )
}